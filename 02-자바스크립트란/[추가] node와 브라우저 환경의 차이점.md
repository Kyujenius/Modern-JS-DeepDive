## 브라우저 환경과 Node.js 환경의 차이점

**“JS는 싱글 스레드인데 비동기가 어떻게 가능하냐”** 라는 질문에 **“Web API에 의존하기 때문이야”** 라고 답하면 브라우저 관점에서만 맞고, Node.js 관점에서는 틀린 설명이다.

### 브라우저 환경

자바스크립트 엔진(V8 등) + Web API (DOM, setTimeout, fetch …)

- 비동기 처리는 Web API들이 담당.
- 따라서 “Web API 덕분이다”라고 해도 말이 됨.

### Node.js 환경

- 자바스크립트 엔진(V8) + libuv(이벤트 루프 + 스레드 풀)
- I/O 작업(파일, 네트워크)은 OS 레벨의 비동기 기능(커널 비동기 호출, epoll/kqueue 등)에 위임.
- 필요 시 libuv의 **스레드 풀(기본 4개, 조정 가능)** 에서 멀티스레드로 실행 후 결과만 이벤트 루프로 전달.
- 즉, Node.js에는 Web API가 아예 없음.

### 올바른 답변의 뉘앙스

- “자바스크립트는 싱글 스레드지만, 비동기가 가능한 이유는 **런타임 환경(브라우저라면 Web API, Node.js라면 libuv + OS 커널 비동기 I/O)** 가 백그라운드에서 작업을 처리하고, 이벤트 루프를 통해 JS 실행 컨텍스트로 결과를 다시 전달하기 때문입니다.”

### 왜 혼동이 생겼을까?

많은 튜토리얼/면접 질문이 브라우저 JavaScript 기준으로만 설명함.
그래서 Node.js까지 일반화해서 **“비동기는 Web API 덕분”** 이라고 말하는 경우가 많음.
하지만 엄밀히 따지면 “호스트 환경의 API 덕분”이라고 해야 정확합니다.

## 그렇다면 npm run dev 시 React 코드는 어떻게 전달되는 걸까?

- dev 서버가 제공한 스크립트(변환된 React 코드)를 브라우저가 받아 실행한다.
- “변환된 React 코드”라고 표현한 건 바로 TS, TSX, JSX 같은 브라우저가 직접 이해하지 못하는 소스를 브라우저가 읽을 수 있는 순수 JavaScript로 바꾼 것을 말한 것
- 실제로 버튼 클릭, 상태 업데이트, DOM 렌더링 같은 React 런타임 동작은 브라우저 JS 엔진(V8/WebKit/SpiderMonkey) 위에서 일어난다.
- 브라우저 환경이므로 document, window, fetch 같은 Web API를 쓸 수 있다.

### 1. Node.js가 하는 일 (개발 중 npm run dev)

- React 소스(JSX, TS 등)는 브라우저가 바로 실행할 수 없음.
- 그래서 **Node.js 위에서 동작하는 도구(Vite/webpack 같은 dev 서버)** 가 소스를 해석하고 → 브라우저가 이해할 수 있는 평범한 JS(ES5/ES6 수준)로 변환해 줍니다.
- 변환된 JS 파일을 HTTP 서버처럼 브라우저에 **서빙(전송)** 합니다.

즉, Node.js는 **“React 앱 실행 환경”이 아니라, “React 앱을 번들링/서빙하는 보조자”** 예요.


### 2. 브라우저가 하는 일

- 브라우저가 dev 서버에서 전달받은 JS 번들을 로드해서 자기 엔진(V8, WebKit 등) 위에서 실행한다.
- 이때 비로소 React가 동작:
- Virtual DOM 계산
- 상태 업데이트 처리
- document, window 같은 Web API 사용
- 즉, React의 런타임은 브라우저 엔진에서 돌고 있는 것

### 3. 혼동 포인트 정리

- “Node.js가 런타임 환경을 만들어주고, 그 내부의 JS 코드들이 다 해석돼서 브라우저가 다시 해석한다?”
- 아니다. Node.js가 JS 코드를 직접 브라우저에 실행시켜주는 게 아닙니다.
- Node.js는 빌드 + 서빙(파일 변환 & 제공) 역할만 하고, 브라우저가 받아서 직접 해석 & 실행한다.

그래서 React 앱의 버튼 클릭, DOM 렌더링 같은 건 전부 브라우저 엔진이 해석한 결과이다. Node.js는 거기까지 개입하지 않는다.

