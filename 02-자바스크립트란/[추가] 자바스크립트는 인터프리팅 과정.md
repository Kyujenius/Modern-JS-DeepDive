## 1. 전통적인 “JS는 인터프리터 언어다”의 의미

- 과거에는 JS 코드 → 바로 해석(interpret) → 실행 이라는 단순 구조.

- 즉, “컴파일 언어처럼 실행 파일을 미리 만드는 게 아니라 런타임에 해석하면서 실행한다”는 뜻으로 인터프리터 언어라고 불렀었다.

## 2. 실제 현대 JS 엔진(V8 등)의 동작

요즘은 단순 인터프리터 방식이 아니고, 혼합 모델을 쓴다고 한다:

1. JS 소스코드 입력

2. 파싱 → AST(추상 구문 트리) 생성

3. 바이트코드로 변환 (Ignition 같은 인터프리터가 실행 가능한 코드)

4. 바이트코드를 실행하면서, 자주 쓰이는 코드 경로를 감지해 JIT(Just-In-Time) 컴파일러가 네이티브 머신 코드로 변환 → 성능 최적화

5. 실행 중 필요하면 최적화 해제(deoptimization)도 가능

## 3. 브라우저 vs Node.js

### 브라우저 환경

- JS 엔진(V8, SpiderMonkey, JavaScriptCore 등)이 소스를 받아서 바이트코드 → 기계어 실행.

- DOM, fetch 같은 Web API는 엔진이 아니라 브라우저 런타임이 제공.

### Node.js 환경

- 역시 JS 엔진(V8)에서 소스를 바이트코드/기계어로 실행.

- fs, http, process 같은 API는 **Node 런타임(libuv, C++ 바인딩 등)** 이 제공.

JS 코드가 “바이트코드로 변환된 후” 실행되는 건 맞지만, **그 바이트코드를 돌려주는 주체는 Node.js 자체가 아니라 엔진(V8)** 입니다. Node.js는 엔진 위에 API를 얹은 런타임 환경이다.

## 4. 정리

JS는 전통적으로 인터프리터 언어라고 불렸지만, 현대에는 **런타임에 소스코드 → 바이트코드 → (필요시 JIT → 기계어)** 로 실행되는 구조를 가진다.
브라우저든 Node.js든, 바이트코드 실행은 JS 엔진이 하고, 주변 API 제공은 런타임 환경이 한다.

“JS가 런타임에 바이트코드로 변환된다” → 맞음

“그 바이트코드가 Node.js나 브라우저 엔진에 들어간다” → 엔진(V8 등)이 실행하는 게 맞고, Node.js/브라우저는 그 엔진을 품은 런타임이라고 보는 게 더 정확하다.
