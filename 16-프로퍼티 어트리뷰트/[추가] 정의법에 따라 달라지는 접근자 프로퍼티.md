# 정의법 따라 달라지는 접근자 프로퍼티

접근자 프로퍼티는 [[Value]], [[Writable]]이 없다는 게 가장 큰 차이이다.
즉, 값 저장 여부가 아니라 getter/setter 정의 여부가 달라질 수 있고, 그에 따라 동작이 달라진다.

## 케이스별 예시

### 1. Getter만 정의 (읽기 전용)

```js
const obj = {
  get x() {
    return 10;
  },
};

console.log(obj.x); // 10
obj.x = 20;
console.log(obj.x); // 10 (setter 없음 → 무시됨)
```

- [[Get]]: 함수 있음
- [[Set]]: undefined
- [[Enumerable]]: true
- [[Configurable]]: true

### 2. Setter만 정의 (쓰기 전용)

```js
const obj = {
set x(value) {
this.\_x = value;
}
};

obj.x = 30;
console.log(obj.x); // undefined (getter 없음)
console.log(obj.\_x); // 30
```

- [[Get]]: undefined
- [[Set]]: 함수 있음
- [[Enumerable]]: true
- [[Configurable]]: true

### 3. Getter + Setter 둘 다 정의 (완전한 접근자)

```js
const obj = {
  _y: 5,
  get y() {
    return this._y;
  },

  set y(value) {
    this._y = value;
  },
};

console.log(obj.y); // 5
obj.y = 20;
console.log(obj.y); // 20
```

- [[Get]]: 함수 있음
- [[Set]]: 함수 있음
- [[Enumerable]]: true
- [[Configurable]]: true

4. defineProperty로 제어

```js
const obj = {};
Object.defineProperty(obj, "z", {
  get() {
    return 100;
  },
  enumerable: false, // 열거 불가
  configurable: false, // 삭제/재정의 불가
});

console.log(obj.z); // 100
console.log(Object.keys(obj)); // [] (enumerable: false)
delete obj.z;
console.log(obj.z); // 100 (삭제 불가)
```

## 최종 정리

- 접근자 프로퍼티는 [[Value]], [[Writable]] 대신 [[Get]], [[Set]]을 가짐.
- getter/setter 정의 여부에 따라 동작이 달라짐 → 읽기 전용 / 쓰기 전용 / 읽기+쓰기 모두 가능.
- [[Enumerable]], [[Configurable]]은 데이터 프로퍼티와 동일하게 동작하고, 경우에 따라 달라질 수 있음.
