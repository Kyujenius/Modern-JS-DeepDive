# 자바스크립트의 객체(Object)

- 자바스크립트는 객체 기반 프로그래밍 언어
- 거의 모든 것이 객체 (원시 값 제외)
- 함수, 배열, 정규표현식 등 → 모두 객체

## 원시 타입 vs 객체 타입

- 원시 타입(Primitive Type)
- 값 자체가 변경 불가능 (immutable value)
- 하나의 값만 표현
- 객체 타입(Object / Reference Type)
- 다양한 타입의 값(원시 값, 다른 객체 등)을 단위로 묶은 복합적 자료구조
- 변경 가능한 값 (mutable value)
- 0개 이상의 **프로퍼티(Property)**로 구성됨

## 객체의 구성 요소

- 프로퍼티(Property) = 키(key) + 값(value)

예시:

```js
var person = {
  name: "Lee",
  age: 20,
};
```

객체 구조 (ASCII 다이어그램)

```js
person
 ├── name: "Lee"
 └── age : 20
```

- person 객체는 name, age 두 개의 `프로퍼티`를 가짐
- 각 `프로퍼티는 키:값 쌍으로 저장`됨

## 객체의 프로퍼티와 메서드

```js
var counter = {
  num: 0,
  increase: function () {
    this.num++;
  },
};
```

- 프로퍼티(Property): 객체의 상태를 나타내는 값 (data)
- 예: num: 0
- 메서드(Method): 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작 (behavior)
- 예: increase: function() { this.num++; }

즉, 객체는 **상태(data)** 와 **동작(behavior)** 을 하나의 단위로 묶어서 구조화할 수 있게 해줌 → 매우 유용한 특성

## 객체와 함수

- 자바스크립트에서 함수도 객체
- 함수는 일급 객체(first-class object):
- 값처럼 변수에 할당 가능
- 다른 함수의 인자로 전달 가능
- 함수에서 반환 가능
- 차이점: 함수는 호출할 수 있다는 특별한 능력이 있음
- 따라서 함수는 객체이면서 호출할 수 있는 값

## 핵심 정리

1. 객체는 **프로퍼티(값)**와 **메서드(동작)**로 이루어짐.
2. 자바스크립트의 함수도 객체 → 메서드로 활용될 수 있음.
3. 객체는 프로그램을 구조화하는 데 매우 중요한 역할을 함.

- 상태(data)와 동작(behavior)을 한곳에 묶어 관리 가능

## 객체 리터럴에 의한 객체 생성

### 1. 클래스 기반 언어와의 차이

- C++, Java 같은 클래스 기반 언어
  → 클래스를 정의한 후 new 연산자와 생성자를 호출해 인스턴스를 생성

- 자바스크립트는 프로토타입 기반 객체지향 언어
  → 다양한 방식으로 객체를 생성할 수 있음

### 2. 객체 생성 방법

자바스크립트에서 객체를 생성하는 대표적인 방법:

- 객체 리터럴 (가장 간단하고 보편적)
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)

### 3. 객체 리터럴

- 가장 일반적이고 간단한 방법
- 중괄호 {} 안에 0개 이상의 프로퍼티를 정의하여 생성

```js
var person = {
  name: "Lee",
  sayHello: function () {
    console.log(`Hello! My name is ${this.name}.`);
  },
};
```

### 특징

1. 변수에 할당되는 시점에 자바스크립트 엔진이 객체를 생성
2. 프로퍼티(Key:Value)와 메서드(Function)를 포함할 수 있음

```js
var person = {
  name: "Lee",
  sayHello: function () {
    console.log(`Hello! My name is ${this.name}.`);
  },
};

console.log(typeof person); // object
console.log(person); // { name: "Lee", sayHello: f }
```

## 요약

- 객체 리터럴은 가장 간단한 객체 생성법
- {} 안에 프로퍼티와 메서드를 정의해 사용
- 실행 시점에 엔진이 자동으로 객체 생성
- 다른 생성 방법(Object(), Object.create(), class)도 있지만 리터럴 방식이 가장 직관적

## 프로퍼티 접근

- 점 표기법(dot notation)
- obj.key
- 대괄호 표기법(bracket notation)
- obj["key"] → 키가 변수이거나 문자열일 때 사용

```js
var person = { name: "Lee", age: 20 };

console.log(person.name); // Lee
console.log(person["age"]); // 20
```

### 값 갱신 (Update)

- 이미 존재하는 프로퍼티에 새로운 값을 할당하면 값이 갱신됨

```js
var person = { name: "Lee" };

person.name = "Kim";
console.log(person.name); // Kim
```

### 프로퍼티 동적 생성 (Dynamic Property Creation)

- 존재하지 않는 키에 값을 할당하면 새로운 프로퍼티가 생성됨

```js
var person = { name: "Lee" };

person.age = 20;
console.log(person.age); // 20
```

### 프로퍼티 삭제 (Delete)

- delete 연산자를 사용하면 프로퍼티 제거 가능
- 존재하지 않는 프로퍼티를 삭제해도 에러 발생하지 않음

```js
var person = { name: "Lee", age: 20 };

delete person.age;
console.log(person.age); // undefined
```

### ES6 객체 리터럴 확장 기능

#### (1) 프로퍼티 축약 표현

- 변수명과 키 이름이 동일하다면 키 생략 가능

```js
let name = "Lee";
let age = 20;

let person = { name, age };
console.log(person); // { name: "Lee", age: 20 }
```

#### (2) 메서드 축약 표현

- function 키워드 생략 가능

```js
let person = {
  name: "Lee",
  sayHello() {
    console.log(`Hi! I'm ${this.name}`);
  },
};

person.sayHello(); // Hi! I'm Lee
```

#### (3) 계산된 프로퍼티 이름 (Computed Property Names)

- 대괄호 []를 사용해 표현식의 결과를 키로 사용 가능

```js
let key = "age";

let person = {
  name: "Lee",
  [key]: 20,
};

console.log(person); // { name: "Lee", age: 20 }
```
