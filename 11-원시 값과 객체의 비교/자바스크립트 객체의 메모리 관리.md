## 1. 객체와 원시값의 차이

### 원시값 (Primitive Value)

- 변경 불가능한 값(Immutable Value).
- 변수에 할당하면 값 자체가 저장됨.
- 새로운 값을 할당하면 기존 값을 바꾸는 것이 아니라 새로운 메모리 공간을 할당.

### 객체 (Reference Value)

- 변경 가능한 값(Mutable Value).
- 변수에 할당하면 객체가 저장된 **메모리 주소(참조 값)** 가 저장됨.
- 참조를 통해 객체 내부 프로퍼티 수정이 가능.

## 2. 객체의 관리 방식

- 객체는 프로퍼티 개수 제한이 없고, 동적으로 추가/삭제 가능.
- 자바스크립트 엔진은 해시 테이블(Hash Table) 기반으로 객체를 관리.
- V8 엔진은 성능 최적화를 위해 **히든 클래스(Hidden Class)** 와 인라인 캐싱(Inline Caching) 등을 사용.

## 3. 객체의 변경 가능성

- 객체 자체를 새로운 값으로 재할당하면 참조가 바뀌지만,
  참조된 객체 내부의 프로퍼티는 자유롭게 변경 가능.
- 따라서 객체는 **변경 가능한 값(Mutable Value)** 로 분류됨.

```js
const person = { name: "Lee" };
person.name = "Kim"; // 내부 프로퍼티 변경 가능
person.address = "Seoul"; // 새로운 프로퍼티 추가 가능
```

## 4. 얕은 복사 vs 깊은 복사

### 얕은 복사 (Shallow Copy)

- 객체의 1단계까지만 복사, 내부에 중첩된 객체는 참조 값만 복사됨.
- 원본 객체와 복사본이 내부 객체를 공유.

### 깊은 복사 (Deep Copy)

- 중첩된 객체까지 모두 새로운 메모리에 복사.
- 원본과 복사본이 완전히 독립.

```js
const o = { x: { y: 1 } };

// 얕은 복사
const c1 = { ...o };
console.log(c1.x === o.x); // true (참조 공유)

// 깊은 복사 (lodash 사용)
const _ = require("lodash");
const c2 = _.cloneDeep(o);
console.log(c2.x === o.x); // false (완전 독립)
```

## 5. 결론

1.  원시값: 불변(immutable), 값 자체를 저장, 재할당 시 새로운 메모리 공간 확보.
2.  객체: 가변(mutable), 참조 값을 저장, 내부 프로퍼티 자유롭게 수정 가능.
3.  복사 방식:

- 얕은 복사 → 참조 공유 (원본과 복사본 연결됨).
- 깊은 복사 → 완전 독립 (원본과 복사본 분리됨).

## 참조에 의한 전달

- 객체를 변수에 할당하면 참조 값(메모리 주소)이 복사된다.
- 두 변수는 동일한 객체를 가리킨다.
- 한쪽에서 변경하면 다른 쪽에도 그대로 반영된다.

```js
var person = { name: "Lee" };
var copy = person;

copy.name = "Kim";
person.address = "Seoul";

console.log(person); // { name: "Kim", address: "Seoul" }
console.log(copy); // { name: "Kim", address: "Seoul" }
```

### 값에 의한 전달과 차이

- 원시 타입: 값 자체가 복사된다. → 독립적
- 객체 타입: 참조 값이 복사된다. → 같은 객체 공유

※ 자바스크립트는 “참조에 의한 전달”이라는 용어를 사용하지 않는다. 모든 것은 값에 의한 전달이다. 단, 값이 원시 값인지 참조 값인지에 따라 동작이 달라질 뿐이다.

### 객체 비교

```js
var person1 = { name: "Lee" };
var person2 = { name: "Lee" };

console.log(person1 === person2); // false
console.log(person1.name === person2.name); // true
```

- 객체 리터럴은 평가될 때마다 새로운 객체를 생성한다.
- 같은 내용을 가져도 다른 메모리 공간에 저장되므로 === 결과는 false.
- 프로퍼티 값이 원시 값이라면 값 자체를 비교하므로 같으면 true.
